#! /usr/bin/perl
# Automatically enables "strict", "warnings", "utf8" and
# Perl 5.10 features

use Mojolicious::Lite;
use DBI;
use RRDs;

use Munin::Common::Defaults;
use Munin::Common::Logger;

my $datafilename = "$Munin::Common::Defaults::MUNIN_DBDIR/datafile.sqlite";

get '/grp' => sub {
	my $self = shift;
	my $id = $self->param('grp_id');
	my $p_id = $self->param('p_id');

	my @params;
	# Actually, the more specific ID *overrides* the other ones, therefore
	# the order is important
	if ($id) {
		@params = ("id = ?", $id);
	} elsif ($p_id) {
		@params = ("p_id = ?", $p_id);
	}

	$self->render(json => get_table_data("grp", @params));
};

get '/nodes' => sub {
	my $self = shift;
	my $id = $self->param('node_id');
	my $grp_id = $self->param('grp_id');

	my @params;
	# Actually, the more specific ID *overrides* the other ones, therefore
	# the order is important
	if ($id) {
		@params = ("id = ?", $id);
	} elsif ($grp_id) {
		@params = ("grp_id = ?", $grp_id);
	}

	$self->render(json => get_table_data("node", @params));
};

get '/services' => sub {
	my $self = shift;
	my $id = $self->param('service_id');
	my $node_id = $self->param('node_id');

	my @params;
	# Actually, the more specific ID *overrides* the other ones, therefore
	# the order is important
	if ($id) {
		@params = ("id = ?", $id);
	} elsif ($node_id) {
		@params = ("node_id = ?", $node_id);
	}

	$self->render(json => get_table_data("service", @params));
};

get '/ds' => sub {
	my $self = shift;
	my $id = $self->param('ds_id');
	my $service_id = $self->param('service_id');

	my @params;
	# Actually, the more specific ID *overrides* the other ones, therefore
	# the order is important
	if ($id) {
		@params = ("id = ?", $id);
	} elsif ($service_id) {
		@params = ("service_id = ?", $service_id);
	}

	$self->render(json => get_table_data("ds", @params));
};

get '/states' => sub {
	my $self = shift;
	my $id = $self->param('state_id');
	my $type = $self->param('state_type');

	my $where = "";
	my @params;
	if ($id) {
		$where .= " AND id = ?";
		push @params, $id;
	}
	if ($type) {
		$where .= " AND type = ?";
		push @params, $type;
	}

	# We cannot use the generic db accessor
	$self->render(json => get_state_data($where, @params));
};

get '/timeseries/*url' => sub {
	my $self = shift;
	my $url = $self->param('url');
	my $format = lc($self->param('format') || "json"); # Default is JSON

	my $end = $self->param('end');
	my $start = $self->param('start');
	my $step = $self->param('step');

	# Here is the meat of the JSON API : transforming some RRD timeseries
	# into a Perl structure.  It is done in a pure MVC idiom, so we can
	# present it later as CSV, JSON, XML (or even PNG & SVG)

	# This will also serve as the basis of the new CGI, SQL-based
	# graphing. We'll just factor the

	# Building up the RRD command line
	my @rrd_opts;
	push @rrd_opts, "--start", $start if $start;
	push @rrd_opts, "--end", $end if $end;
	push @rrd_opts, "--step", $step if $step;

	# Get the DS for the URL
	my $dbh = DBI->connect_cached("dbi:SQLite:dbname=$datafilename","","") or die $DBI::errstr;
	my $sth = $dbh->prepare_cached( "
		SELECT dr.*, d.name FROM ds_rrd dr
		INNER JOIN ds d ON d.id = dr.id
		INNER JOIN url u ON u.id = dr.id AND u.type = 'ds' AND u.path = ?
		UNION ALL
		SELECT dr.*, d.name FROM ds_rrd dr
		INNER JOIN ds d ON d.id = dr.id
		INNER JOIN url u ON u.id = d.service_id AND u.type = 'service' AND u.path = ?
		");
	$sth->execute($url, $url);

	my (@rrd_def, @rrd_xport);
	while (my ($_id, $_filename, $_field, $_name) = $sth->fetchrow_array) {
		push @rrd_def, "DEF:f_$_id=$Munin::Common::Defaults::MUNIN_DBDIR/$_filename:$_field:AVERAGE";
		push @rrd_xport, "XPORT:f_$_id:$_name";
	}

	die "Not found" unless @rrd_def;

	INFO "RRDs::xport(@rrd_opts, @rrd_def, @rrd_xport);";

	my ($real_start, $real_end, $real_step, $nb_vars, $columns, $values) = RRDs::xport(@rrd_opts, @rrd_def, @rrd_xport);
	my $timeseries = {
		meta => {
			start => $real_start,
			step => $real_step,
			end => $real_end,
			rows => (scalar @$values),
			columns => (scalar @$columns),
			legend => $columns,
		},
		data => $values,
	};
	$self->render(json => $timeseries);
};

# Start the Mojolicious command system
app->start;

sub get_table_data
{
	my ($table, $where_clause, @params) = @_;
	$where_clause = (! $where_clause) ? "" : "WHERE $where_clause";

	my $dbh = DBI->connect_cached("dbi:SQLite:dbname=$datafilename","","") or die $DBI::errstr;

	my $sth = $dbh->prepare_cached( "SELECT * FROM $table $where_clause");
	$sth->execute(@params);

	my $nodes = $sth->fetchall_arrayref(
		{}
		#	{ Slice => {} }, # Each row is stored as a hashref
	);

	my $sth_attr = $dbh->prepare_cached(
		"SELECT name, value FROM $table"."_attr WHERE id = ?",
	);
	foreach my $node (@$nodes) {
		$sth_attr->execute($node->{id});
		while (my ($_name, $_value) = $sth_attr->fetchrow_array) {
			$node->{attr}{$_name} = $_value;
		}
	}

	return $nodes;
}

# We cannot use the same DB accessor, as the state table is special
sub get_state_data
{
	my ($where_clause, @params) = @_;

	my $dbh = DBI->connect_cached("dbi:SQLite:dbname=$datafilename","","") or die $DBI::errstr;

	my $sth = $dbh->prepare_cached( "SELECT * FROM state WHERE 1 = 1 $where_clause");
	$sth->execute(@params);

	my $nodes = $sth->fetchall_arrayref(
		{}
		#	{ Slice => {} }, # Each row is stored as a hashref
	);

	return $nodes;
}
