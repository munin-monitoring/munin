#!@@PERL@@ -T
# -*- cperl -*-

=begin comment

Copyright (C) 2004-2010 Jimmy Olsen, Steve Schnepp

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; version 2 dated June,
1991.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

$Id$

=end comment

=cut

use strict;
use warnings;
use IO::Handle;
use Storable;

use CGI::Fast qw(:cgi);
use CGI::Carp qw(fatalsToBrowser);

use Munin::Common::Defaults;
use Log::Log4perl qw( :easy );

Log::Log4perl->easy_init($DEBUG);

my $conffile = "$Munin::Common::Defaults::MUNIN_CONFDIR/munin.conf";

my $nb_request = 0;
my $nb_request_max = 0;
while (new CGI::Fast) {
    # 1rst thing is to validate the URL. Only a subset of chars are allowed.
    # Return 404 if not compliant, w/o logging.
    # This fixes http://bugs.debian.org/668666 and closes a lots of other potential bugs.
    if ( has_offending_chars($ENV{PATH_INFO}) || has_offending_chars($ENV{QUERY_STRING}) ) {
        # If parameters are not valid, just pretend we didn't find anything.
        print "Status: 404 Not Found\r\n",
          "Content-Type: application/json\r\n",
          "X-Munin-Pid: $$\r\n",
          "X-Munin-Request: $nb_request/$nb_request_max\r\n",
          "\r\n";
        next;
    }

    my $path = $ENV{PATH_INFO} || "";

    DEBUG "Request path is $path";

    my ($dom, $host, $serv, $field) =
      $path =~ m#^/(.*)/([^/]+)/([\w-]+)/([\w-]+)#; ## avoid bug in vim

    DEBUG "asked for ($dom, $host, $serv, $field)";

    my $value = get_value_filename($dom, $host, $serv, $field);
    if (! defined $value) {
	print "Status: 404 Not Found\r\n",
	  "Content-Type: application/json\r\n",
	  "X-Munin-Pid: $$\r\n",
	  "X-Munin-Request: $nb_request/$nb_request_max\r\n",
	  "\r\n";
	next;
    }

    # Now send it: headers
    print "Status: 200\r\n",
      "Content-Type: application/json\r\n",
      "X-Munin-Pid: $$\r\n",
      "X-Munin-Request: $nb_request/$nb_request_max\r\n",
    "";

    print "\r\n";

    my ($prev_epoch, $prev_value) = @{ $value->{previous} };
    my ($cur_epoch, $cur_value) = @{ $value->{current} };

    # ... and json data
    print "{
      'previous': [
        '$prev_epoch',
        '$prev_value'
      ],
      'current': [
        '$cur_epoch',
        '$cur_value'
      ]
    }";

} continue {
	$nb_request++;
	if ($nb_request_max && $nb_request > $nb_request_max) {
		# Cycle
		last;
	}
}
# END FAST-CGI LOOP - Time to die.  Nicely.

exit 0;

sub starts_with
{
	my ($s, $start) = @_;
	return ( substr($s, 0, length($start)) eq $start );
}


sub get_value_filename {
    my $domain  = shift;
    my $name    = shift;
    my $service = shift;
    my $field   = shift;

    my $filename = "$Munin::Common::Defaults::MUNIN_DBDIR/state-$domain-$name.storable";

    my $s = Storable::retrieve($filename);
    return undef if ! defined $s;

    my $rrd_file_prefix = "$Munin::Common::Defaults::MUNIN_DBDIR/$domain/$name-$service-";

    for my $key (sort keys %{$s->{value}}) {

	# XXX - Avoiding map{} in order to be more readable
	next unless starts_with($key, $rrd_file_prefix);

	my $f = substr($key, length($rrd_file_prefix));
	DEBUG "found $f";

	$f =~ s/-[dcg].rrd:\S+$//;
	if ($f eq $field) {
		return $s->{value}{$key};
	} 
    }

    # Not found
    return undef;
}

sub has_offending_chars {
	my $url_part = shift;
	return 0 if ! defined $url_part;
	# "." and ":" are for ip_ in IPv4 & IPv6
	return $url_part =~ m:[^a-zA-Z0-9_/.,=&\:-]:;
}

# vim: syntax=perl ts=8
