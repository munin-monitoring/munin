#!@@PERL@@
#
# $Id$
#
# $Log$
# Revision 1.26  2004/09/13 21:45:55  jimmyo
# node- and domain_order settings now does not exclude unmentioned entries.
#
# Revision 1.25  2004/09/10 21:06:56  jimmyo
# Made summarised grahps work with dynamically generated graphs.
#
# Revision 1.24  2004/09/10 19:24:18  jimmyo
# Added new option "graph_sums" which creates summarised graphs.
#
# Revision 1.23  2004/09/08 15:25:33  ilmari
# Use @@PERL@@ in all perl shebang lines.
#
# Revision 1.22  2004/09/07 20:38:33  jimmyo
# Added the internal field name to the HTML output as a tooltip.
#
# Revision 1.21  2004/09/07 18:56:03  jimmyo
# Small interface improvements in the HTML output.
#
# Revision 1.20  2004/09/01 19:46:01  jimmyo
# Removed debug info.
#
# Revision 1.19  2004/09/01 19:44:46  jimmyo
# Munin-html img-tags now sets image size, which helps when rendering pages with lots of graphs.
#
# Revision 1.18  2004/06/24 14:32:18  jimmyo
# More work on output_graphs (renamed to graph_strategy, amongst others).
#
# Revision 1.17  2004/06/23 17:38:40  jimmyo
# * Created munin-cgi-graph, which creates dynamic graphs.
# * Added munin.conf option "output_graphs (cgi|cron)" which
#   defaults to cron.
#
# Revision 1.16  2004/05/21 06:21:46  jimmyo
# Removed superfluous debug output.
#
# Revision 1.15  2004/05/20 22:30:08  jimmyo
# * Munin-limits added to distro.
# * Breached limis now show up in overview and node view.
#
# Revision 1.14  2004/05/20 20:47:20  jimmyo
# The server programs now open the log file at an earlier point.
#
# Revision 1.13  2004/05/20 19:05:53  jimmyo
# Show categories
#
# Revision 1.12  2004/05/20 13:57:11  jimmyo
# Set categories to some of the plugins.
#
# Revision 1.11  2004/05/20 12:20:24  jimmyo
# Added "graph_category" option, to categorise plugins.
#
# Revision 1.10  2004/05/16 16:58:41  jimmyo
# Added a definition file (definitions.html) to the server distribution.
#
# Revision 1.9  2004/05/16 11:27:39  jimmyo
# Added warning and critical statuses to the info table in the service view.
#
# Revision 1.8  2004/05/16 00:36:19  jimmyo
# Forgo an option
#
# Revision 1.7  2004/05/16 00:33:07  jimmyo
# Added a descriptionary table at the bottom of the service view page. Also added "graph_info" and "<field>.info" which can be used by plugins to supply supplementary information for it.
#
# Revision 1.6  2004/05/12 10:46:47  jimmyo
# Bugfix regarding logo namechange from logo.gif to logo.png, when installing.
#
# Revision 1.5  2004/01/29 17:40:10  jimmyo
# Fixed pod typos patched by Lupe Christoph (SF#884092)
#
# Revision 1.4  2004/01/29 17:34:06  jimmyo
# Updated copyright information
#
# Revision 1.3  2004/01/29 17:13:46  jimmyo
# Enabled domain_order-option.
#
# Revision 1.2  2004/01/15 15:20:01  jimmyo
# Making things workable after name change. Upping for test verwion.
#
# Revision 1.1  2004/01/02 18:50:01  jimmyo
# Renamed occurrances of lrrd -> munin
#
# Revision 1.1.1.1  2004/01/02 15:18:07  jimmyo
# Import of LRRD CVS tree after renaming to Munin
#
# Revision 1.10  2003/12/02 10:15:14  jimmyo
# Minor bugfix reported by Chan Wilson
#
# Revision 1.9  2003/12/02 09:55:56  jimmyo
# Fixed stupid brain-bug (Chan Wilson)
#
# Revision 1.8  2003/11/07 20:46:12  jimmyo
# Only require Config::General if using old config format.
#
# Revision 1.7  2003/11/07 19:00:16  jimmyo
# Put lockfiles in the right place
#
# Revision 1.6  2003/11/07 17:43:16  jimmyo
# Cleanups and log entries
#
#
$|=1;

use strict;
use HTML::Template;
use Getopt::Long;
use Munin;
use POSIX qw(strftime);

my @times = ( "day", "week", "month", "year" );


my $DEBUG=0;
my $VERSION="@@VERSION@@";
my $conffile = "@@CONFDIR@@/munin.conf";
my $force_root = 0;
my $do_usage = 0;
my $do_version = 0;
my $log = new IO::Handle;

# Get options
$do_usage=1  unless 
GetOptions ( "host=s"       => \(),
             "force-root!"  => \$force_root,
	     "service=s"    => \(),
	     "config=s"     => \$conffile,
	     "debug!"       => \$DEBUG,
	     "help"         => \$do_usage, 
	     "version!"     => \$do_version );

if ($do_usage)
{
    print "Usage: $0 [options]

Options:
    --[no]force-root    Force running, even as root. [--noforce-root]
    --help		View this message.
    --debug		View debug messages.
    --version		View version information.
    --service <service>	Compatability. No effect.
    --host <host>	Compatability. No effect.
    --config <file>	Use <file> as configuration file. 
			[/etc/munin/munin.conf]

";
    exit 0;
}

if ($do_version)
{
    print "munin-html version $VERSION.\n";
    print "Written by Knut Haugen, Audun Ytterdal, Jimmy Olsen, Tore Anderson / Linpro AS\n";
    print "\n";
    print "Copyright (C) 2002-2004\n";
    print "This is free software released under the GNU Public License. There is NO\n";
    print "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    exit 0;
}

if ($> == 0 and !$force_root)
{
    print "You are running this program as root, which is neither smart nor necessary.
If you really want to run it as root, use the --force-root option. Else, run
it as the user \"munin\". Aborting.\n\n";
    exit (1);
}

my $config;
my $limits;
$config = &munin_config ($conffile, $config);
$limits = &munin_readconfig ($config->{dbdir}."/limits", 1, 1);

logger("Starting munin-html, checking lock");

munin_runlock("$config->{rundir}/munin-html.lock");
my $template = HTML::Template->new(filename => "$config->{tmpldir}/munin-overview.tmpl",
				   die_on_bad_params => 0,
				   loop_context_vars => 1);

my $domaintemplate = HTML::Template->new(filename => "$config->{tmpldir}/munin-domainview.tmpl",
				   die_on_bad_params => 0,
				   loop_context_vars => 1);

my $nodetemplate = HTML::Template->new(filename => "$config->{tmpldir}/munin-nodeview.tmpl",
				       die_on_bad_params => 0,
				       loop_context_vars => 1);

my $servicetemplate = HTML::Template->new(filename => "$config->{tmpldir}/munin-serviceview.tmpl",
				       die_on_bad_params => 0,
				       loop_context_vars => 1);

my @domains;

my @domainorder;
if ($config->{domain_order}) {
    @domainorder = split / /, $config->{domain_order};
}
foreach my $d (sort (keys %{$config->{domain_order}})) {
    unless (grep (/^$d$/, @domainorder)) {
	push @domainorder, $d;
    }
}

#Make sure the logo and the stylesheet file is in the html dir
my @files = ("style.css", "logo.png", "definitions.html");
foreach my $file( (@files) ) {
    if ((! -e "$config->{htmldir}/$file") or
	 (-e "$config->{tmpldir}/$file") and 
	 ((stat ("$config->{tmpldir}/$file"))[9] > (stat("$config->{htmldir}/$file"))[9])) {
        unless (system("cp", "$config->{tmpldir}/$file", "$config->{htmldir}/")){
            logger("copied $file into htmldir");
        } else {
            logger("could not copy $file into htmldir");
        }
    }
}

#make domain list
my @domainlist = map { { DOMAIN => $_ } } @domainorder;
my $timestamp = strftime("%Y-%m-%d T %T", localtime);
for my $domain (@domainorder) {
    logger("processing domain: $domain");
    my %domain;
    $domain{domain}=$domain;
    my @nodes;
    my @nodeorder = ();
    if ($config->{domain}->{$domain}->{node_order}) {
	@nodeorder = split / /, $config->{domain}->{$domain}->{node_order};
    } 
    foreach my $n (sort (keys %{$config->{domain}->{$domain}->{node}}))
    {
	unless (grep (/^$n$/, @nodeorder))
	{
	    push @nodeorder, $n;
	}
    }
    for my $node (@nodeorder) {
        logger("processing node: $node");
	my %node;
	$node{node}=$node;
	$node{url}="$domain/$node.html";
	my @services;
	my @categories;
	my %tmp_cats;
	my @serviceorder;
	if ($config->{domain}->{$domain}->{node}->{$node}->{service_order}) {
	    @serviceorder = split / /, $config->{domain}->{$domain}->{node}->{$node}->{service_order};
	} else {
	    @serviceorder = sort (keys %{$config->{domain}->{$domain}->{node}->{$node}->{client}});
	}
	
	for my $service (@serviceorder) {
	    logger("processing service: $service");
	    next unless defined( $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service} )
	                    &&  $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service} ne "";
	    next unless (munin_get_bool ($config, "graph", 1, $domain, $node, $service));
	    my @service;
	    my %service;
	    my $fieldnum = 0;
	    my @graph_info;
	    my @field_info;
	    $service{service}=$service;
	    $service{label}=$config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{graph_title};
		
		my $method = &munin_get_val ($config, "graph_strategy", "cron");
		if ($method eq "cgi")
		{
			$service{imgday}="/munin/dyn/munin-cgi-graph/$domain/$node-$service-day.png";
			$service{imgweek}="/munin/dyn/munin-cgi-graph/$domain/$node-$service-week.png";
			$service{imgmonth}="/munin/dyn/munin-cgi-graph/$domain/$node-$service-month.png";
			$service{imgyear}="/munin/dyn/munin-cgi-graph/$domain/$node-$service-year.png";

			if (&munin_get_bool_val ($config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{"graph_sums"}, 0))
			{
			    $service{imgweeksum} = "/munin/dyn/munin-cgi-graph/$domain/$node-$service-week-sum.png";
			    $service{imgyearsum} = "/munin/dyn/munin-cgi-graph/$domain/$node-$service-year-sum.png";
			}
		}
		else
		{
			$service{imgday}="$node-$service-day.png";
			$service{imgweek}="$node-$service-week.png";
			$service{imgmonth}="$node-$service-month.png";
			$service{imgyear}="$node-$service-year.png";

			for my $scale (@times)
			{
				if (my ($w, $h) = &get_png_size (&munin_get_picture_filename ($config, $domain, $node, $service, $scale)))
				{
					$service{"img".$scale."width"} = $w;
					$service{"img".$scale."height"} = $h;
				}
			}

			if (&munin_get_bool_val ($config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{"graph_sums"}, 0))
			{
			    $service{imgweeksum} = "$node-$service-week-sum.png";
			    $service{imgyearsum} = "$node-$service-year-sum.png";
			    for my $scale (["week", "year"])
			    {
				    if (my ($w, $h) = &get_png_size (&munin_get_picture_filename ($config, $domain, $node, $service, $scale, 1)))
				    {
					    $service{"img".$scale."sumwidth"} = $w;
					    $service{"img".$scale."sumheight"} = $h;
				    }
			    }
			}
		}
	    $service{url}="$node-$service.html";
	    $service{domain}="$domain";
	    $service{node}=$node;
	    $service{category}= $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{graph_category} || "other";

        # Do "help" section
		if (defined $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{graph_info})
		{
			my %graph_info;
			$graph_info{info} = $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{graph_info};
			push @{$service{graphinfo}}, \%graph_info;
		}
		$service{fieldlist} .= "<tr><th align='left' valign='top'>Field</th><th align='left' valign='top'>Type</th><th align='left' valign='top'>Warn</th><th align='left' valign='top'>Crit</th><th></tr>";
		foreach my $field (keys %{$config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}})
		{
			if ($field =~ /^([^\.]+)\.label/)
			{
				my $f = $1;
				next unless (&munin_draw_field ($config->{domain}->{$domain}->{node}->{$node}, $service, $f));

				my %field_info;
				$fieldnum++;

				$field_info{'hr'}      = 1 unless ($fieldnum % 3);
				$field_info{'field'}   = $f;
				$field_info{'label'}   = $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{$f.".label"} || $f;
				$field_info{'type'}    = lc ($config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{$f.".type"} || "GAUGE");
				$field_info{'warn'}    = $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{$f.".warning"} || "None";
				$field_info{'crit'}    = $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{$f.".critical"} || "None";
				$field_info{'info'}    = $config->{domain}->{$domain}->{node}->{$node}->{client}->{$service}->{$f.".info"} || "";

				my $state = &munin_field_status ($config, $limits, $domain, $node, $service, $f);
				if (defined $state)
				{
					$field_info{'state_warning'}  = 1 if $state eq "warning";
					$field_info{'state_critical'} = 1 if $state eq "critical";
					$field_info{'state_unknown'}  = 1 if $state eq "unknown";
				}
				push @{$service{fieldinfo}}, \%field_info;
			}
		}

		{
			my $state = &munin_service_status ($config, $limits, $domain, $node, $service);
			if (defined $state)
			{
				$service{'state_warning'}  = 1 if $state eq "warning";
				$service{'state_critical'} = 1 if $state eq "critical";
				$service{'state_unknown'}  = 1 if $state eq "unknown";
			}
		}

	    push @services, \%service;
	    push @service, \%service;
	    push @{$tmp_cats{$service{'category'}}}, \%service;
	    $servicetemplate->param(SERVICES => \@service,
				    SERVICE => $service,
				    NODE => $node,
				    DOMAIN => $domain, 
				    DOMAINS => \@domainlist, 
				    TIMESTAMP => $timestamp);
	    open (FILE, ">$config->{htmldir}/$domain/$node-$service.html") or die "Cannot open $config->{htmldir}/$domain/$node-$service.html";
	    print FILE $servicetemplate->output;
	    close FILE;
	}
	foreach my $key (keys %tmp_cats)
	{
	    next if $key eq "other";
	    my %tmp;
	    my $state = &munin_category_status ($config, $limits, $domain, $node, $key);
	    print "DEBUG: Pushing category \"$node\" -> \"$key\"...\n" if $DEBUG;
	    if (defined $state)
	    {
		    $tmp{'state_warning'}  = 1 if $state eq "warning";
		    $tmp{'state_critical'} = 1 if $state eq "critical";
		    $tmp{'state_unknown'}  = 1 if $state eq "unknown";
	    }
	    $tmp{name} = ucfirst $key;
	    $tmp{services} = \@{$tmp_cats{$key}};
	    $tmp{node} = $node;
	    $tmp{domain} = $domain;
	    push @categories, \%tmp;
	}
	if (defined $tmp_cats{'other'})
	{
	    my $key = 'other';
	    my %tmp;
	    my $state = &munin_category_status ($config, $limits, $domain, $node, $key);
	    print "DEBUG: Pushing category \"$node\" -> \"$key\"...\n" if $DEBUG;
	    if (defined $state)
	    {
		    $tmp{'state_warning'}  = 1 if $state eq "warning";
		    $tmp{'state_critical'} = 1 if $state eq "critical";
		    $tmp{'state_unknown'}  = 1 if $state eq "unknown";
	    }
	    $tmp{name} = ucfirst $key;
	    $tmp{services} = \@{$tmp_cats{$key}};
	    $tmp{node} = $node;
	    $tmp{domain} = $domain;
	    push @categories, \%tmp;
	}
	$nodetemplate->param(SERVICES => \@services,
			     NODE => $node,
			     DOMAIN => $domain,
			     DOMAINS => \@domainlist, 
			     TIMESTAMP => $timestamp,
			     CATEGORIES => \@categories);
	open (FILE, ">$config->{htmldir}/$domain/$node.html") or die "Cannot open $config->{htmldir}/$domain/$node.html";
 	print FILE $nodetemplate->output;
	close FILE;
	$node{services} = \@services;
	$node{categories} = \@categories;
	$node{domain} = $domain;
	push @nodes,\%node;

    }
    $domaintemplate->param(NODES => \@nodes,
                           DOMAIN => $domain, 
                           DOMAINS => \@domainlist, 
                           TIMESTAMP => $timestamp);
    open (FILE, ">$config->{htmldir}/$domain/index.html") or die "Cannot open $config->{htmldir}/index.html";
    print FILE $domaintemplate->output;
    close FILE;
    
    $domain{nodes} = \@nodes;
    $domain{domain} = $domain;
    push @domains,\%domain;
}

$template->param(DOMAINS => \@domains, 
                 TIMESTAMP => $timestamp);
open (FILE, ">$config->{htmldir}/index.html") or die "Cannot open $config->{htmldir}/index.html";
print FILE $template->output;
close FILE;

sub logger_open {
    my $dirname = shift;

    if (!$log->opened)
    {
	  unless (open ($log, ">>$dirname/munin-html.log"))
	  {
		  print STDERR "Warning: Could not open log file \"$dirname/munin-html.log\" for writing: $!";
	  }
    }
}

sub logger {
  my ($comment) = @_;
  my $now = strftime "%b %d %H:%M:%S", localtime;

  if ($log->opened)
  {
	  print $log "$now - $comment\n";
  }
  else
  {
	  if (defined $config->{logdir})
	  {
		  if (open ($log, ">>$config->{logdir}/munin-html.log"))
		  {
			  print $log "$now - $comment\n";
		  }
		  else
		  {
			  print STDERR "Warning: Could not open log file \"$config->{logdir}/munin-html.log\" for writing: $!";
			  print STDERR "$now - $comment\n";
		  }
	  }
	  else
	  {
		  print STDERR "$now - $comment\n";
	  }
    }
}

sub get_png_size
{
	my $filename = shift;
	my $width = undef;
	my $height = undef;

	if (open (PNG, $filename))
	{
		my $incoming;
		binmode (PNG);
		if (read (PNG, $incoming, 4))
		{
			if ($incoming =~ /PNG$/)
			{
				if (read (PNG, $incoming, 12))
				{
					if (read (PNG, $incoming, 4))
					{
						$width = unpack ("N", $incoming);
						read (PNG, $incoming, 4);
						$height = unpack ("N", $incoming);
					}
				}
			}
		}
		close (PNG);
	}

	return ($width, $height);
}

logger("munin-html finished");
close $log;

=head1 NAME

munin-html - A program to draw html-pages on an Munin installation

=head1 SYNOPSIS

munin-html [options]

=head1 OPTIONS

=over 5

=item B<< --[no]force-root >>

Force running as root (stupid and unnecessary). [--noforce-root]

=item B<< --service <service> >>

Limit services to those of E<lt>serviceE<gt>. Multiple --service options may be supplied. [unset]

=item B<< --host <host> >>

Limit hosts to those of E<lt>host<gt>. Multiple --host options may be supplied. [unset]

=item B<< --config <file> >>

Use E<lt>fileE<gt> as configuration file. [/etc/munin/munin.conf]

=item B<< --help >>

View help message.

=item B<< --[no]debug >>

If set, view debug messages. [--nodebug]

=back

=head1 DESCRIPTION

Munin-html is a part of the package Munin, which is used in combination
with Munin's node.  Munin is a group of programs to gather data from
Munin's nodes, graph them, create html-pages, and optionally warn Nagios
about any off-limit values.

Munin-html creates the html pages.

=head1 FILES

	@@CONFDIR@@/munin.conf
	@@DBDIR@@/datafile
	@@LOGDIR@@/munin-html
	@@HTMLDIR@@/*
	@@STATEDIR@@/*

=head1 VERSION

This is munin-html version @@VERSION@@

=head1 AUTHORS

Knut Haugen, Audun Ytterdal and Jimmy Olsen.

=head1 BUGS

munin-html does, as of now, not check the syntax of the configuration file.

Please report other bugs in the bug tracker at L<http://munin.sf.net/>.

=head1 COPYRIGHT

Copyright © 2002-2004 Knut Haugen, Audun Ytterdal, and Jimmy Olsen / Linpro AS.

This is free software; see the source for copying conditions. There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.

This program is released under the GNU General Public License

=cut

# vim:syntax=perl:ts=8
