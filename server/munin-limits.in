#!@@PERL@@
# Nagios
#
# $Log$
# Revision 1.9  2004/11/12 23:18:52  jimmyo
# Added new options notify_enable and notify_text, to allow more finely tuned notifications (both what to notify and what text to send.)
#
# Revision 1.8  2004/09/24 16:31:07  jimmyo
# Bugfixes.
#
# Revision 1.7  2004/09/08 15:25:33  ilmari
# Use @@PERL@@ in all perl shebang lines.
#
# Revision 1.6  2004/06/08 15:30:34  jimmyo
# The server programs now open the log file at an earlier point.
#
# Revision 1.5  2004/05/20 22:30:08  jimmyo
# * Munin-limits added to distro.
# * Breached limis now show up in overview and node view.
#
# Revision 1.4  2004/01/29 17:40:10  jimmyo
# Fixed pod typos patched by Lupe Christoph (SF#884092)
#
# Revision 1.3  2004/01/29 17:34:06  jimmyo
# Updated copyright information
#
# Revision 1.2  2004/01/15 15:20:01  jimmyo
# Making things workable after name change. Upping for test verwion.
#
# Revision 1.1  2004/01/02 18:50:01  jimmyo
# Renamed occurrances of lrrd -> munin
#
# Revision 1.1.1.1  2004/01/02 15:18:08  jimmyo
# Import of LRRD CVS tree after renaming to Munin
#
# Revision 1.4  2003/11/07 20:46:12  jimmyo
# Only require Config::General if using old config format.
#
# Revision 1.3  2003/11/07 17:43:16  jimmyo
# Cleanups and log entries
#

use strict;

use Munin;
use POSIX qw(strftime);
use Getopt::Long;
use Text::Balanced qw (extract_bracketed);
my $DEBUG=0;
my $conffile = "@@CONFDIR@@/munin.conf";
my $do_usage = 0;
my @limit_hosts = ();
my @limit_services = ();
my $force_root = 0;
my %notes = ();
my $default_notify_text = '${var:graph_title}:${if:cfields  CRITICALs:${loop<,>:cfields  ${var:label} is ${var:value} (outside range ${var:critical})${if:extinfo : ${var:extinfo}}}.}${if:wfields  WARNINGs:${loop<,>:wfields  ${var:label} is ${var:value} (outside range ${var:warning})${if:extinfo : ${var:extinfo}}}.}${if:ufields  UNKNOWNs:${loop<,>:ufields  ${var:label} is ${var:value}${if:extinfo : ${var:extinfo}}}.}';

my $log = new IO::Handle;

# Get options
$do_usage=1  unless 
GetOptions ( "force-root!"  => \$force_root,
	     "host=s"       => \@limit_hosts,
	     "service=s"    => \@limit_services,
	     "config=s"     => \$conffile,
	     "debug!"       => \$DEBUG,
	     "help"         => \$do_usage );

if ($do_usage)
{
    print "Usage: $0 [options]

Options:
    --[no]force-root    Force running, even as root. [--noforce-root]
    --help		View this message.
    --debug		View debug messages.
    --service <service>	Limit notified services to <service>. Multiple 
    			--service options may be supplied.
    --host <host>	Limit notified hosts to <host>. Multiple --host 
    			options may be supplied.
    --config <file>	Use <file> as configuration file. 
    			[/etc/munin/munin.conf]

";
    exit 0;
}

if ($> == 0 and !$force_root)
{
    print "You are running this program as root, which is neither smart nor necessary.
If you really want to run it as root, use the --force-root option. Else, run
it as the user \"munin\". Aborting.\n\n";
    exit (1);
}

my $config = &munin_config ($conffile);
my $modified=0;

logger("Starting munin-limits, checking lock");
munin_runlock("$config->{dbdir}/munin-limits.lock");
logger("Created lock: $config->{dbdir}/munin-limits.lock");

	


for my $domain ( keys %{$config->{domain}}) {
    logger ("processing domain: $domain");
    process_domain($domain);
}
&munin_writeconfig ("$config->{dbdir}/limits", \%notes);
logger("munin-limits finished.");


sub process_domain {
    my ($domain) = @_;
    for my $node ( keys %{$config->{domain}->{$domain}->{node}}) {
    	if (@limit_hosts and !grep (/^$node$/, @limit_hosts))
	{
		logger ("skipping node: $node");
		next;
	}
	logger ("processing node: $node");
	process_node($domain,$node ,$config->{domain}->{$domain}->{node}->{$node} );
    }
}

sub process_node {
  my ($domain,$name,$node) = @_;
  for my $client (keys %{$node->{client}}) {
      logger ("processing service: $client") if $DEBUG;
      process_service($domain,$name,$client,$node->{client}->{$client});
      generate_service_message ($domain, $name, $client, $node->{client}->{$client});
  }
}

sub process_service {
  my $critical= undef;
  my ($domain, $name,$clientname,$client) = @_;
  return unless $client;
  for my $service (keys %$client) {
    if ($service =~ /(^.*)\.label/) {
	my $key = $1;
	next unless ((exists $client->{"$key.warning"}) || ($client->{"$key.critical"}));
	logger ("processing field: $key") if $DEBUG;
    	if (@limit_services and !grep (/^$service$/, @limit_services))
	{
		next;
	}
	my @critical = (undef, undef);
	my @warning  = (undef, undef);
	if (defined $client->{"$key.critical"} and 
	    $client->{"$key.critical"} =~ /^\s*([-\d]*):([-\d]*)\s*$/)
	{
		$critical[0] = $1 if length $1;
		$critical[1] = $2 if length $2;
		logger ("processing critical: $domain -> $name -> $clientname -> $key -> $critical[0] : $critical[1]") if $DEBUG;
	}
	elsif (defined $client->{"$key.critical"} and
	    $client->{"$key.critical"} =~ /^\s*([-\d]+)\s*$/)
	{
		$critical[1] = $1 if defined $1;
		logger ("processing critical: $domain -> $name -> $clientname -> $key -> $critical[0] : $critical[1]") if $DEBUG;
	}
	elsif (defined $client->{"$key.critical"})
	{
	    @critical = (0, 0);
	    logger ("processing critical: $domain -> $name -> $clientname -> $key -> $critical[0] : $critical[1]") if $DEBUG;
	}
	if (defined $client->{"$key.warning"} and 
	    $client->{"$key.warning"} =~ /^\s*([-\d]*):([-\d]*)\s*$/)
	{
		$warning[0] = $1 if length $1;
		$warning[1] = $2 if length $2;
		logger ("processing warning: $domain -> $name -> $clientname -> $key -> $warning[0] : $warning[1]") if $DEBUG;
	}
	elsif (defined $client->{"$key.warning"} and
	    $client->{"$key.warning"} =~ /^\s*([-\d]+)\s*$/)
	{
		$warning[1] = $1 if defined $1;
		logger ("processing warning: $domain -> $name -> $clientname -> $key -> $warning[0] : $warning[1]") if $DEBUG;
	}
	elsif (defined $client->{"$key.warning"})
	{
	    @warning = (0, 0);
	    logger ("processing warning: $domain -> $name -> $clientname -> $key -> $warning[0] : $warning[1]") if $DEBUG;
	}
	my $filename = "$config->{dbdir}/$domain/$name-$clientname-$key-".
	    lc substr (($client->{"$key.type"}||"GAUGE"),0,1) . ".rrd";
	my $value = sprintf "%.2f",&munin_fetch("$filename");

	# Some fields that are nice to have in the plugin output
	$client->{$key.".value"} = $value;
	$client->{'fields'} = join (' ', map { $_ =~ s/\.label$//; $_} grep (/\.label/, keys %$client));
	
	logger ("value: $domain -> $name -> $clientname -> $key : $value") if $DEBUG;
	if ((defined ($critical[0]) and $value < $critical[0]) or
	    (defined ($critical[1]) and $value > $critical[1])) {
	    $critical[0] ||= "";
	    $critical[1] ||= "";
	    $notes{$domain}{$name}{$clientname}{"$key.critical"} = 
		(defined $client->{"$key.extinfo"}?
		    "$value (not in $critical[0]:$critical[1]): ".
		    $client->{"$key.extinfo"}:
		    "Value is $value. Critical range ($critical[0]:$critical[1]) exceeded");
	}
	elsif ((defined ($warning[0]) and $value < $warning[0]) or 
	       (defined ($warning[1]) and $value > $warning[1])) {
	    	$warning[0] ||= "";
	    	$warning[1] ||= "";
		$notes{$domain}{$name}{$clientname}{"$key.warning"} = 
		  (defined $client->{"$key.extinfo"}?
			"$value (not in $warning[0]:$warning[1]): ".
			$client->{"$key.extinfo"}:
			"Value is $value. Warning range ($warning[0]:$warning[1]) exceeded");
	}
      }
    }
}

sub generate_service_message {
    my $critical= undef;
    my ($domain, $name,$clientname,$client) = @_;
    return unless $client;
    my $worst = "";
    my @crits = ();
    my @warns = ();
    my @unkns = ();

    foreach my $key (keys %{$notes{$domain}{$name}{$clientname}})
    {
	if ($key =~ /^([^\.]+)\.critical$/)
	{
	    $worst = "critical";
	    push @crits, $1;
	}
    	elsif ($key =~ /^([^\.]+)\.warning$/)
	{
	    $worst = "warning" if $worst ne "critical";
	    push @warns, $1;
	}
    	elsif ($key =~ /^([^\.]+)\.unknown$/)
	{
	    $worst = "unknown" unless $worst;
	    push @unkns, $1;
	}
    }
    $client->{'cfields'} = join " ", @crits;
    $client->{'wfields'} = join " ", @warns;
    $client->{'ufields'} = join " ", @unkns;
    $client->{'numcfields'} = scalar @crits;
    $client->{'numwfields'} = scalar @warns;
    $client->{'numufields'} = scalar @unkns;
    my %fs = map { $_ =~ s/\.(critical|warning)$//; $_ => 1;} grep (/\.(critical|warning)$/, keys %$client);
    foreach (@crits, @warns, @unkns)
    {
	delete $fs{$_} if exists $fs{$_};
    }
    $client->{'ofields'} = join " ", keys %fs;

    $client->{'numofields'} = keys (%fs);

    if ($worst)
    {
	$notes{$domain}{$name}{$clientname}{$worst} = message_expand (munin_get_val ($config, "notify_text", $default_notify_text, $domain, $name, $clientname), $client);
    }
}


sub message_expand {
    my $text   = shift;
    my $client = shift;
    my $prefix = shift || "";
    my @res    = ();

    while (length ($text))
    {   
	if ($text =~ /^([^\$]+|)(?:\$(\{.*)|)$/)
	{
	    push @res, $1;
	    $text = $2;
	}   
	my @a = extract_bracketed ($text, '{}');
	if ($a[0] =~ /^\{var:(\S+)\}$/)
	{
	    $a[0] = (defined $client->{$prefix.$1} ? $client->{$prefix.$1} : "");
	}
	elsif ($a[0] =~ /^\{loop<([^>]+)>:\s*(\S+)\s(.+)\}$/)
	{
	    my $d = $1;
	    my $f = $2;
	    my $t = $3;
	    my @res  = ();
	    if (defined $client->{$f})
	    {
		foreach my $sub (split /\s+/, $client->{$f})
		{
		    push @res, message_expand ($t, $client, $sub.".");
		}
	    } 
	    $a[0] = join ($d, @res);
	}
	elsif ($a[0] =~ /^\{loop:\s*(\S+)\s(.+)\}$/)
	{
	    my $f = $1;
	    my $t = $2;
	    my $res  = "";
	    if (defined $client->{$f})
	    {
		foreach my $sub (split /\s+/, $client->{$f})
		{
		    $res .= message_expand ($t, $client, $sub.".");
		}
	    } 
	    $a[0] = $res;
	}
	elsif ($a[0] =~ /^\{if:\s*(\!)?(\S+)\s(.+)\}$/)
	{
	    my $n = $1;
	    my $f = $2;
	    my $t = $3;
	    my $res  = "";
	    my $check = (defined $client->{$prefix.$f} and length($client->{$prefix.$f}) and $client->{$prefix.$f} ne "0");

	    $check = (!defined $client->{$prefix.$f} or !length($client->{$prefix.$f}) or $client->{$prefix.$f} eq "0")
		if $n;

	    if ($check)
	    {
		$res .= message_expand ($t, $client, $prefix);
	    } 
	    $a[0] = $res;
	}
	push @res, $a[0];
	$text = $a[1];
    }

    return join ('', @res);
}

sub logger_open {
    my $dirname = shift;

    if (!$log->opened)
    {
	  unless (open ($log, ">>$dirname/munin-limits.log"))
	  {
		  print STDERR "Warning: Could not open log file \"$dirname/munin-limits.log\" for writing: $!";
	  }
    }
}

sub logger {
  my ($comment) = @_;
  my $now = strftime "%b %d %H:%M:%S", localtime;

  if ($log->opened)
  {
	  print $log "$now - $comment\n";
  }
  else
  {
	  if (defined $config->{logdir})
	  {
		  if (open ($log, ">>$config->{logdir}/munin-graph.log"))
		  {
			  print $log "$now - $comment\n";
		  }
		  else
		  {
			  print STDERR "Warning: Could not open log file \"$config->{logdir}/munin-graph.log\" for writing: $!";
			  print STDERR "$now - $comment\n";
		  }
	  }
	  else
	  {
		  print STDERR "$now - $comment\n";
	  }
    }
}

close $log;

=head1 NAME

munin-limits - A program to check for any off-limit values

=head1 SYNOPSIS

munin-limits [options]

=head1 OPTIONS

=over 5

=item B<< --service <service> >>

Limit services to those of E<lt>serviceE<gt>. Multiple --service options may be supplied. [unset]

=item B<< --host <host> >>

Limit hosts to those of E<lt>host<gt>. Multiple --host options may be supplied. [unset]

=item B<< --config <file> >>

Use E<lt>fileE<gt> as configuration file. [@@CONFDIR@@/munin.conf]

=item B<< --[no]force >>

Force sending of messages ieven if you normally wouldn't. [--noforce]

=item B<< --[no]force-root >>

Force running as root (stupid and unnecessary). [--noforce-root]

=item B<< --removeok >>

Reset warning status (remove .ok-files).

=item B<< --help >>

View help message.

=item B<< --[no]debug >>

If set, view debug messages. [--nodebug]

=back

=head1 DESCRIPTION

Munin-limits is a part of the package Munin, which is used in combination
with Munin's node.  Munin is a group of programs to gather data from
Munin's nodes, graph them, create html-pages, and optionally warn Nagios
about any off-limit values.

Munin-limits checks if any values are above or below the set limits, and saves these notes to a file. This file
is later used by programs like munin-nagios (to warn nagios) and munin-html (to incorporate them in the web
display).

If a service has fields with "warning" or "critical"-options (e.g. "load.warning 10"), and the munin-server
configuration file contains the necessary configuration options, munin-limits will check its value.

=head1 FILES

	@@CONFDIR@@/munin.conf
	@@DBDIR@@/*
	@@STATEDIR@@/*

=head1 VERSION

This is munin-limits version @@VERSION@@

=head1 AUTHORS

Audun Ytterdal and Jimmy Olsen.

=head1 BUGS

munin-limits does, as of now, not check the syntax of the configuration file.

Please report other bugs in the bug tracker at L<http://munin.sf.net/>.

=head1 COPYRIGHT

Copyright © 2002-2004 Knut Haugen, Audun Ytterdal, and Jimmy Olsen / Linpro AS.

This is free software; see the source for copying conditions. There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.

This program is released under the GNU General Public License

=cut

# vim: syntax=perl ts=8
